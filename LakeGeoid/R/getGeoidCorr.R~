f <- function(par){
    "[<-" <- ADoverload("[<-")
    getAll(par, data)
    sdObs<-exp(logsdObs)
    sigmaRW<-exp(logSigmaRW)
    tau <- exp(logTau)
    kappa <- exp(logKappa)
    Q <- tau*(kappa^4*spde$c0+2*kappa^2*spde$g1+spde$g2)

    ntime<-length(mymu)
    nll <- -sum(dnorm(mymu[2:ntime],mymu[1:(ntime-1)],sigmaRW*sqrt(utime[2:ntime]-utime[1:(ntime-1)]),TRUE))
    PredObs <- projObs%*%omega 
    nll<- nll-dgmrf(omega, Q=Q, log = TRUE) #hack
    
    nll <-nll -sum(dnorm(obs,PredObs+mymu[timeid],sdObs,TRUE))
  
    sdField <- sqrt(1/(4*pi*tau^2*kappa^2))
    range <- sqrt(8)/kappa
    ADREPORT(sdField)
    ADREPORT(range)
    nll
}



##' Fit getLakeGeoid
##' @param dat Data
##' @param maxEdge Reach distance of virtual stations 
##' @param myshape shapefile
##' @import RTMB
##' @import fmesher
##' @import terra
##' @import sf
##' @examples
##' fit<-getLakeGeoid(dat,2000,myshape)
##' @export



getLakeGeoid<-function(dat,maxEdge,myshape,UTM=TRUE){
    xy<-cbind(dat$lon,dat$lat)
    if(UTM){
        xy<-ll2utm(dat)
        myproj<-getProjUTM(dat$lon,dat$lat)
        # project shapefile
        myshape <- st_transform (myshape, crs = myproj)
    }
    
    mymesh<-fm_mesh_2d(boundary =myshape$geometry,max.edge=maxEdge)
    spde <- fm_fem(mymesh)
    
    
    projObs <- fm_basis(mymesh, loc = xy)
    #trim observations on the border of the polygon 
    idx<-which(rowSums(projObs)>0.5)
    dat<-dat[idx,]
    xy<-xy[idx,]
    projObs <- fm_basis(mymesh , loc = xy)

    timeid<-as.integer(as.factor(dat$time))
    utime<-unique(dat$time)
# data list
    data<-list()
    data$mesh <- mymesh
    data$spde <- spde
    data$projObs <- projObs
    data$obs <- dat$wse
    data$timeid<-timeid
    data$utime<-utime

# define parameters
    par <- list()
    par$mymu <- rep(mean(data$obs),length(utime))
    par$logsdObs<-log(0.2)
    par$logTau <- 0  
    par$logKappa <- 0  
    par$omega <- numeric(data$mesh$n)
    par$logSigmaRW<-0

    data <- local({data<-data; environment()})
    environment(f) <- data

    obj <- MakeADFun(f, par, random=c("omega","mymu"), silent=FALSE)
    fit <- nlminb(obj$par, obj$fn, obj$gr,control=list(eval.max=2000, iter.max=2000))

    sdr <- sdreport(obj)
    pl <- as.list(sdr,"Est")
    plsd <- as.list(sdr,"Std")
    plr <- as.list(sdr,"Est", report=TRUE)  
    plrsd <- as.list(sdr,"Std", report=TRUE)
    mymu<-pl$mymu
    omega<-pl$omega
    out<-list(omega=omega,wl=mymu, time=utime,mymesh=mymesh)
    class(out)<-"LakeGeoid"
    out
}



##' Plot an object returned by the function getLakeGeoid()
##' @param fit Object returned by getLakeGeoid()
##' @param zlim vector with the zlim interval c(low,high), defined by the field "omega" if not specified 
##' @param dat The raw water level data can be added to the plot
##' @param doSave plot is saved to a pdf file
##' @param ... Additional argumants to plot
##' @importFrom fields image.plot
##' @import viridis
##' @keywords plot
##' @export

plot.LakeGeoid<-function(fit,zlim=NULL,dat=NULL,doSave=FALSE,...){
    colS<-'blue3'
    mymesh<-fit$mymesh
    omega<-fit$omega
    wl<-fit$wl
    time<-fit$time
    if(is.null(zlim)){
        eps <- 1e-9
        zlim <-  c(min(omega,na.rm=TRUE)-eps, max(omega,na.rm=TRUE)+eps)

    }
    if(doSave)pdf('out.pdf',12,6)
    par(mfrow=c(1,2),mar=c(4,4,1,6))
    cc<-viridis::mako(500)
    tc<-apply(col2rgb(cc)/255, 2, function(x)rgb(x[1],x[2],x[3],1))
    plot(mymesh, col="gray", lwd=.01,xlab='Easting',ylab='Northing')
    nt<-nrow(mymesh$graph$tv)
    lamv<-apply(mymesh$graph$tv,1,function(idx)mean(omega[idx]))
    mybreaks<-seq(zlim[1],zlim[2],length=501)
    lamc<-tc[as.numeric(cut(lamv,breaks = mybreaks))]
    dummy<-sapply(1:nrow(mymesh$graph$tv),function(i){idx<-mymesh$graph$tv[i,];polygon(mymesh$loc[idx,1], mymesh$loc[idx,2], col=lamc[i], border=NA)})
    fields::image.plot(as.matrix(mybreaks), col=tc, type="n", legend.only=TRUE)
    box()
    axis(1)
    axis(2)
    par(mar=c(4,4,1,1))
    plot(time,wl,t='b',xlab='Time in decimal years',ylab='Elevation w.r.t. EGM2008',pch=3,col=colS,...)
    if(!is.null(dat)){points(dat$time,dat$wse,col='gray',pch='.')
        lines(time,wl,t='b',pch=3,col=colS,lwd=2)
    }

    if(doSave)dev.off()
}



##' Predict geoid correction error   
##' @param fit Object returned by getLakeGeoid()
##' @param newdat a data set at least including the columns named "lon" and "lat" with the coordinates where the corretion should be predicted. 
##' @param UTM boolean to indicate if the estimated field is in a UTM projection (FALSE mean degrees) 
##' @import terra
##' @import sf
##' @import fmesher
##' @keywords predict
##' @export

getGeoidCorr<-function(fit,newdat,UTM=TRUE){

    omega<-fit$omega
    mymesh<-fit$mymesh
    xy<-cbind(newdat$lon,newdat$lat)
    if(UTM) xy<-ll2utm(newdat)
    projObs <- fm_basis(mymesh, loc = xy)
    PredObs <- as.vector(projObs%*%omega)
    gCorr<-rep(NA,length(PredObs))
    # identify observations outside model area
    idx<-which(rowSums(as.array(projObs))>0.5)
    gCorr[idx]<-PredObs[idx]
    newdat<-cbind(newdat,gCorr)
    
    #val <-PredObs[idx]
    #nCol <- 40
#tc <- viridis::mako(nCol)
#eps <- 1e-9
#breaks <-  seq(min(val,na.rm=TRUE)-eps, max(val,na.rm=TRUE)+eps, length=nCol+1)
#valc<-tc[as.integer(cut(val,breaks = breaks))]
#plot(C2$lon,C2$lat, col=valc, pch=16,xlab='Longitude',ylab='Latitude')
#ticks <- pretty(val)
#fields::image.plot(as.matrix(val), nlevel=nCol, col=tc, type="n", legend.only=TRUE, horizontal=FALSE, breaks=breaks)
    newdat

}



    
